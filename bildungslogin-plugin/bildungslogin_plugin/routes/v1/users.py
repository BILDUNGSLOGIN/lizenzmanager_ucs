# -*- coding: utf-8 -*-
from __future__ import annotations

from typing import Any, Dict, List, Set

from fastapi import APIRouter, Depends, HTTPException
from id_broker_plugin.id_broker_plugin import kelvin_session
from pydantic import BaseModel, ValidationError, constr, validator
from starlette import status

from ucsschool.apis.opa import OPAClient, opa_instance
from ucsschool.apis.plugins.auth import get_token
from ucsschool.kelvin.client import InvalidRequest, Session, User as KelvinUser, UserResource

NonEmptyStr = constr(min_length=1)
NoStarStr = constr(regex=r"^[^*]+$")
router = APIRouter(tags=["users"])


class SchoolContext(BaseModel):
    classes: Set[NonEmptyStr] = set()
    roles: Set[NonEmptyStr] = set()


class User(BaseModel):
    id: NonEmptyStr
    first_name: NonEmptyStr
    last_name: NonEmptyStr
    user_name: NonEmptyStr
    context: Dict[NonEmptyStr, SchoolContext]

    class Config:
        schema_extra = {
            "example": {
                "id": "4378687645",
                "user_name": "m.mustermann",
                "first_name": "Max",
                "last_name": "Mustermann",
                "context": {"School1": {"classes": ["1a"], "roles": ["teacher", "staff"]}},
            }
        }

    @validator("context")
    def context_not_empty(cls, value: Dict[str, SchoolContext]):
        if not value:
            raise ValueError("The context must not be empty!")
        return value

    @validator("context")
    def uniform_ucsschool_role_in_all_schools(cls, value: Dict[str, SchoolContext]):
        """
        Validates that all SchoolContexts have the same set of roles.

        Users with different roles in different schools are not yet supported.
        """
        role_sets = [school_context.roles for school_context in value.values()]
        if not all(roles == role_sets[0] for roles in role_sets):
            raise ValueError("All schools must have the same set of roles!")
        return value

    @classmethod
    def from_kelvin_user(cls, user: Dict[str, Any]) -> User:
        """
        Takes a dictionary of the form that is generated by KelvinUser.as_dict
        and returns a User from it.

        :param user: The dictionary to create the User from
        :return: The user object created from the provided data
        :raises ValueError: If any of the school roles is malformed
        :raises ValidationError: If the user is malformed
        """
        user_data = {
            "id": user.get("record_uid", ""),
            "first_name": user.get("firstname", ""),
            "last_name": user.get("lastname", ""),
            "user_name": user.get("name", ""),
        }
        context = {}
        for school in user.get("schools", []):
            context[school] = SchoolContext(
                classes=user.get("school_classes", {}).get(school, []),
                roles=get_roles_for_school(user.get("ucsschool_roles", []), school),
            )
        user_data["context"] = context
        return cls(**user_data)

    @property
    def ucsschool_roles(self) -> List[str]:
        """
        The ucsschool_roles generated from the school_context roles.
        """
        return [
            f"{role}:school:{school}"
            for school, school_context in self.context.items()
            for role in school_context.roles
        ]

    @property
    def school_classes(self) -> Dict[str, List[str]]:
        """
        The school_classes in the form that is present in the Kelvin API.
        """
        return {school: list(school_context.classes) for school, school_context in self.context.items()}

    @property
    def school(self) -> str:
        """
        The users "main school".
        This is just the first school present in the context field. It is needed since Kelvin needs a specific
        main school.
        """
        return self.schools[0]

    @property
    def schools(self) -> List[str]:
        """
        A list of all schools of the user.
        """
        return [school for school in self.context]

    @classmethod
    def without_prefix(cls, user: User, school_authority: str):
        """
        Creates a user from the provided user object and removes the school authority prefix.
        """
        user_data = user.dict()
        user_data["user_name"] = user.user_name
        user_data["context"] = {
            school: school_context for school, school_context in user.context.items()
        }
        return cls(**user_data)

    @classmethod
    def with_prefix(cls, user: User, school_authority: str):
        """
        Creates a user from the provided user object and adds the school authority prefix.
        """
        prefix = f"{school_authority}-"
        user_data = user.dict()
        user_data["user_name"] = f"{prefix}{user.user_name}"
        user_data["context"] = {
            f"{prefix}{school}": school_context for school, school_context in user.context.items()
        }
        return cls(**user_data)


def get_roles_for_school(roles: List[str], school: str) -> Set[str]:
    """
    Takes a list of ucsschool_roles and returns a list of user roles for the given school.

    >>> get_roles_for_school(["teacher:school:School1", "student:school:School2"], "school1")
    {'teacher'}

    :param roles: The list of ucsschool_roles to filter
    :param school: The school to filter the roles for
    :return: The list of user roles for the given school
    :raises ValueError: If any of the role strings is malformed
    """
    filtered_roles = set()
    for role in roles:
        role_parts = role.split(":")
        if len(role_parts) != 3 or not all(role_parts):
            raise ValueError(f"The role {role} is malformed!")
        if (
            role_parts[1] == "school"
            and role_parts[2] == school
            and role_parts[0] in ("student", "teacher", "staff")
        ):
            filtered_roles.add(role_parts[0])
    return filtered_roles


async def search_kelvin_obj(
    school_authority: str, resource: KelvinResource, **search_args
) -> KelvinObject:
    """
    Searches for an object via the Kelvin API and returns it.

    :param school_authority: The school_authority to search the object in
    :param resource: The KelvinResource to use for searching for the object
    :param search_args: search arguments passed to the resources search method
    :return: The found KelvinObject
    :raises HTTPException: If the request failed, if no object or if more than one object was found
    """
    try:
        kelvin_objects = [kelvin_object async for kelvin_object in resource.search(**search_args)]
    except InvalidRequest as exc:
        raise HTTPException(status_code=exc.status, detail=exc.reason) from exc
    if len(kelvin_objects) == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Object with search parameters {search_args} not found in {school_authority}!",
        )
    if len(kelvin_objects) > 1:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"More than one object with search parameters {search_args} "
            f"found for school_authority {school_authority}!",
        )
    return kelvin_objects[0]


async def get_user_by_id(
    user_id: NoStarStr,
    school_authority: NonEmptyStr,
    session: Session = Depends(kelvin_session),
    policy_instance: OPAClient = Depends(opa_instance),
    token: str = Depends(get_token),
) -> KelvinUser:
    await policy_instance.check_policy_true_or_raise(
        "provisioning_plugin/school_authority_admin",
        token,
        request={"school_authority": school_authority},
    )
    return await search_kelvin_obj(
        school_authority,
        UserResource(session=session),
        record_uid=user_id,
        source_uid=f"IDBROKER-{school_authority}",
    )


@router.get("/users/{user_id}", response_model=User)
async def get(
    school_authority: NonEmptyStr,
    user_id: NoStarStr,
    user: KelvinUser = Depends(get_user_by_id),
) -> Dict[str, Any]:
    try:
        return User.without_prefix(User.from_kelvin_user(user.as_dict()), school_authority)
    except (ValidationError, ValueError) as exc:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"The user {user_id} in school_authority {school_authority} is malformed.",
        ) from exc
